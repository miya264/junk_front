"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/messages/page",{

/***/ "(app-pages-browser)/./src/utils/api.ts":
/*!**************************!*\
  !*** ./src/utils/api.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n// 環境変数の読み込みを確実にする\nconst getApiBaseUrl = ()=>{\n    // まずビルド時の環境変数を試す\n    let endpoint = \"http://127.0.0.1:8000\";\n    // クライアントサイドでの動的判定\n    if (true) {\n        // 本番環境のURLパターンを検出（Vercel、Netlify、GitHub Pages等）\n        const isProd = window.location.hostname !== \"localhost\" && window.location.hostname !== \"127.0.0.1\" && !window.location.hostname.includes(\"localhost\");\n        if (isProd && !endpoint) {\n            // 本番環境なのに環境変数がない場合はエラーとする\n            console.error(\"Production environment detected but NEXT_PUBLIC_API_ENDPOINT not set. Please configure the environment variable.\");\n            throw new Error(\"API endpoint not configured for production environment. Please set NEXT_PUBLIC_API_ENDPOINT.\");\n        }\n        console.log(\"Client-side env check:\", {\n            hostname: window.location.hostname,\n            isProd,\n            envVariable: \"http://127.0.0.1:8000\",\n            resolvedEndpoint: endpoint\n        });\n    }\n    const defaultEndpoint = \"http://127.0.0.1:8000\";\n    const finalEndpoint = endpoint || defaultEndpoint;\n    console.log(\"Environment variable NEXT_PUBLIC_API_ENDPOINT:\", \"http://127.0.0.1:8000\");\n    console.log(\"Using API endpoint:\", finalEndpoint);\n    return finalEndpoint;\n};\nconst API_BASE_URL = getApiBaseUrl();\nclass ApiError extends Error {\n    constructor(status, message){\n        super(message);\n        this.status = status;\n        this.name = \"ApiError\";\n    }\n}\nasync function fetchApi(endpoint, options) {\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    console.log(\"API Request: \".concat((options === null || options === void 0 ? void 0 : options.method) || \"GET\", \" \").concat(url));\n    try {\n        const response = await fetch(url, {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...options === null || options === void 0 ? void 0 : options.headers\n            },\n            mode: \"cors\",\n            credentials: \"omit\",\n            ...options\n        });\n        console.log(\"API Response: \".concat(response.status, \" \").concat(response.statusText));\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>\"Unable to read error response\");\n            console.error(\"API Error Response: \".concat(errorText));\n            throw new ApiError(response.status, \"HTTP error! status: \".concat(response.status, \", message: \").concat(errorText));\n        }\n        const data = await response.json();\n        console.log(\"API Success:\", data);\n        return data;\n    } catch (error) {\n        console.error(\"API Fetch Error:\", error);\n        if (error instanceof ApiError) {\n            throw error;\n        }\n        if (error instanceof TypeError && error.message.includes(\"fetch\")) {\n            throw new Error(\"Network error: Unable to connect to server. Please check your internet connection and try again.\");\n        }\n        throw new Error(\"Network error: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n    }\n}\nconst api = {\n    async sendMessage (request) {\n        return fetchApi(\"/api/chat\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    async getSessions () {\n        return fetchApi(\"/api/sessions\");\n    },\n    async createSession () {\n        return fetchApi(\"/api/sessions\", {\n            method: \"POST\"\n        });\n    },\n    async sendFlexiblePolicyMessage (request) {\n        return fetchApi(\"/api/policy-flexible\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    async getSessionState (sessionId) {\n        return fetchApi(\"/api/session-state/\".concat(sessionId));\n    },\n    async healthCheck () {\n        try {\n            const response = await fetchApi(\"/\");\n            return response;\n        } catch (error) {\n            console.error(\"Health check failed:\", error);\n            throw error;\n        }\n    },\n    async testConnection () {\n        try {\n            await this.healthCheck();\n            return true;\n        } catch (error) {\n            console.error(\"Connection test failed:\", error);\n            return false;\n        }\n    },\n    async saveProjectStepSections (request) {\n        return fetchApi(\"/api/project-step-sections\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    async getProjectStepSections (projectId, stepKey) {\n        return fetchApi(\"/api/project-step-sections/\".concat(projectId, \"/\").concat(stepKey));\n    },\n    async searchCoworkers () {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", department = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        const params = new URLSearchParams();\n        if (query) params.append(\"q\", query);\n        if (department) params.append(\"department\", department);\n        return fetchApi(\"/api/coworkers/search?\".concat(params.toString()));\n    },\n    async createProject (request) {\n        return fetchApi(\"/api/projects\", {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    async getProject (projectId) {\n        return fetchApi(\"/api/projects/\".concat(projectId));\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsS0FBS0o7UUFDOUIsSUFBSUMsWUFBWUMsT0FBT0UsTUFBTSxDQUFDLGNBQWNIO1FBRTVDLE9BQU9wQyxTQUFxQix5QkFBMkMsT0FBbEJxQyxPQUFPRyxRQUFRO0lBQ3RFO0lBRUEsTUFBTUMsZUFBY3RCLE9BQTZCO1FBQy9DLE9BQU9uQixTQUFrQixpQkFBaUI7WUFDeENHLFFBQVE7WUFDUmlCLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0g7UUFDdkI7SUFDRjtJQUVBLE1BQU11QixZQUFXVixTQUFpQjtRQUNoQyxPQUFPaEMsU0FBa0IsaUJBQTJCLE9BQVZnQztJQUM1QztBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2FwaS50cz9iOTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIOeSsOWig+WkieaVsOOBruiqreOBv+i+vOOBv+OCkueiuuWun+OBq+OBmeOCi1xyXG5jb25zdCBnZXRBcGlCYXNlVXJsID0gKCkgPT4ge1xyXG4gIC8vIOOBvuOBmuODk+ODq+ODieaZguOBrueSsOWig+WkieaVsOOCkuippuOBmVxyXG4gIGxldCBlbmRwb2ludCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9FTkRQT0lOVDtcclxuICBcclxuICAvLyDjgq/jg6njgqTjgqLjg7Pjg4jjgrXjgqTjg4njgafjga7li5XnmoTliKTlrppcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIOacrOeVqueSsOWig+OBrlVSTOODkeOCv+ODvOODs+OCkuaknOWHuu+8iFZlcmNlbOOAgU5ldGxpZnnjgIFHaXRIdWIgUGFnZXPnrYnvvIlcclxuICAgIGNvbnN0IGlzUHJvZCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gJ2xvY2FsaG9zdCcgJiYgXHJcbiAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09ICcxMjcuMC4wLjEnICYmXHJcbiAgICAgICAgICAgICAgICAgICAhd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluY2x1ZGVzKCdsb2NhbGhvc3QnKTtcclxuICAgIFxyXG4gICAgaWYgKGlzUHJvZCAmJiAhZW5kcG9pbnQpIHtcclxuICAgICAgLy8g5pys55Wq55Kw5aKD44Gq44Gu44Gr55Kw5aKD5aSJ5pWw44GM44Gq44GE5aC05ZCI44Gv44Ko44Op44O844Go44GZ44KLXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2R1Y3Rpb24gZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IE5FWFRfUFVCTElDX0FQSV9FTkRQT0lOVCBub3Qgc2V0LiBQbGVhc2UgY29uZmlndXJlIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4nKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgZW5kcG9pbnQgbm90IGNvbmZpZ3VyZWQgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuIFBsZWFzZSBzZXQgTkVYVF9QVUJMSUNfQVBJX0VORFBPSU5ULicpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQ2xpZW50LXNpZGUgZW52IGNoZWNrOicsIHtcclxuICAgICAgaG9zdG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSxcclxuICAgICAgaXNQcm9kLFxyXG4gICAgICBlbnZWYXJpYWJsZTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0VORFBPSU5ULFxyXG4gICAgICByZXNvbHZlZEVuZHBvaW50OiBlbmRwb2ludFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGRlZmF1bHRFbmRwb2ludCA9ICdodHRwOi8vMTI3LjAuMC4xOjgwMDAnO1xyXG4gIGNvbnN0IGZpbmFsRW5kcG9pbnQgPSBlbmRwb2ludCB8fCBkZWZhdWx0RW5kcG9pbnQ7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ0Vudmlyb25tZW50IHZhcmlhYmxlIE5FWFRfUFVCTElDX0FQSV9FTkRQT0lOVDonLCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfRU5EUE9JTlQpO1xyXG4gIGNvbnNvbGUubG9nKCdVc2luZyBBUEkgZW5kcG9pbnQ6JywgZmluYWxFbmRwb2ludCk7XHJcbiAgXHJcbiAgcmV0dXJuIGZpbmFsRW5kcG9pbnQ7XHJcbn07XHJcblxyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBnZXRBcGlCYXNlVXJsKCk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VSZXF1ZXN0IHtcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgc2VhcmNoX3R5cGU/OiAnZmFjdCcgfCAnbmV0d29yayc7XHJcbiAgZmxvd19zdGVwPzogJ2FuYWx5c2lzJyB8ICdvYmplY3RpdmUnIHwgJ2NvbmNlcHQnIHwgJ3BsYW4nIHwgJ3Byb3Bvc2FsJztcclxuICBjb250ZXh0PzogYW55O1xyXG4gIHNlc3Npb25faWQ/OiBzdHJpbmc7XHJcbiAgcHJvamVjdF9pZD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlUmVzcG9uc2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgY29udGVudDogc3RyaW5nO1xyXG4gIHR5cGU6ICd1c2VyJyB8ICdhaSc7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgc2VhcmNoX3R5cGU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdFNlc3Npb24ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZsZXhpYmxlUG9saWN5UmVzcG9uc2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgY29udGVudDogc3RyaW5nO1xyXG4gIHN0ZXA6IHN0cmluZztcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBzZXNzaW9uX2lkOiBzdHJpbmc7XHJcbiAgcHJvamVjdF9pZD86IHN0cmluZztcclxuICBuYXZpZ2F0ZV90bz86IHN0cmluZzsgLy8g44K544OG44OD44OX56e75YuV44Gu5aC05ZCI44Gr44K/44O844Ky44OD44OI44K544OG44OD44OX44GM6Kit5a6a44GV44KM44KLXHJcbiAgdHlwZT86IHN0cmluZzsgICAgICAgIC8vIFwibmF2aWdhdGVcIuOBruWgtOWQiOOBr+OCueODhuODg+ODl+enu+WLlVxyXG4gIGZ1bGxfc3RhdGU/OiB7XHJcbiAgICBhbmFseXNpc19yZXN1bHQ/OiBzdHJpbmc7XHJcbiAgICBvYmplY3RpdmVfcmVzdWx0Pzogc3RyaW5nO1xyXG4gICAgY29uY2VwdF9yZXN1bHQ/OiBzdHJpbmc7XHJcbiAgICBwbGFuX3Jlc3VsdD86IHN0cmluZztcclxuICAgIHByb3Bvc2FsX3Jlc3VsdD86IHN0cmluZztcclxuICAgIGxhc3RfdXBkYXRlZF9zdGVwPzogc3RyaW5nO1xyXG4gICAgc3RlcF90aW1lc3RhbXBzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25TdGF0ZSB7XHJcbiAgc2Vzc2lvbl9pZDogc3RyaW5nO1xyXG4gIHByb2plY3RfaWQ/OiBzdHJpbmc7XHJcbiAgYW5hbHlzaXNfcmVzdWx0Pzogc3RyaW5nO1xyXG4gIG9iamVjdGl2ZV9yZXN1bHQ/OiBzdHJpbmc7XHJcbiAgY29uY2VwdF9yZXN1bHQ/OiBzdHJpbmc7XHJcbiAgcGxhbl9yZXN1bHQ/OiBzdHJpbmc7XHJcbiAgcHJvcG9zYWxfcmVzdWx0Pzogc3RyaW5nO1xyXG4gIGxhc3RfdXBkYXRlZF9zdGVwPzogc3RyaW5nO1xyXG4gIHN0ZXBfdGltZXN0YW1wcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFN0ZXBTZWN0aW9uIHtcclxuICBzZWN0aW9uX2tleTogc3RyaW5nO1xyXG4gIGNvbnRlbnQ6IHN0cmluZztcclxuICBsYWJlbD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0U3RlcFNlY3Rpb25SZXF1ZXN0IHtcclxuICBwcm9qZWN0X2lkOiBzdHJpbmc7XHJcbiAgc3RlcF9rZXk6IHN0cmluZztcclxuICBzZWN0aW9uczogUHJvamVjdFN0ZXBTZWN0aW9uW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFN0ZXBTZWN0aW9uUmVzcG9uc2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgcHJvamVjdF9pZDogc3RyaW5nO1xyXG4gIHN0ZXBfa2V5OiBzdHJpbmc7XHJcbiAgc2VjdGlvbl9rZXk6IHN0cmluZztcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb3dvcmtlciB7XHJcbiAgaWQ6IG51bWJlcjtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcG9zaXRpb24/OiBzdHJpbmc7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICBkZXBhcnRtZW50X25hbWU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdENyZWF0ZVJlcXVlc3Qge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBvd25lcl9jb3dvcmtlcl9pZDogbnVtYmVyO1xyXG4gIG1lbWJlcl9pZHM6IG51bWJlcltdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG4gIHN0YXR1czogc3RyaW5nO1xyXG4gIG93bmVyX2Nvd29ya2VyX2lkOiBudW1iZXI7XHJcbiAgb3duZXJfbmFtZTogc3RyaW5nO1xyXG4gIG1lbWJlcnM6IENvd29ya2VyW107XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGF0dXM6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9ICdBcGlFcnJvcic7XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFwaTxUPihlbmRwb2ludDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdEluaXQpOiBQcm9taXNlPFQ+IHtcclxuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGBBUEkgUmVxdWVzdDogJHtvcHRpb25zPy5tZXRob2QgfHwgJ0dFVCd9ICR7dXJsfWApO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxyXG4gICAgICB9LFxyXG4gICAgICBtb2RlOiAnY29ycycsXHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgQVBJIFJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+ICdVbmFibGUgdG8gcmVhZCBlcnJvciByZXNwb25zZScpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBBUEkgRXJyb3IgUmVzcG9uc2U6ICR7ZXJyb3JUZXh0fWApO1xyXG4gICAgICB0aHJvdyBuZXcgQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30sIG1lc3NhZ2U6ICR7ZXJyb3JUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zb2xlLmxvZygnQVBJIFN1Y2Nlc3M6JywgZGF0YSk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJIEZldGNoIEVycm9yOicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBpRXJyb3IpIHtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIGNvbm5lY3QgdG8gc2VydmVyLiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uIGFuZCB0cnkgYWdhaW4uJyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhcGkgPSB7XHJcbiAgYXN5bmMgc2VuZE1lc3NhZ2UocmVxdWVzdDogTWVzc2FnZVJlcXVlc3QpOiBQcm9taXNlPE1lc3NhZ2VSZXNwb25zZT4ge1xyXG4gICAgcmV0dXJuIGZldGNoQXBpPE1lc3NhZ2VSZXNwb25zZT4oJy9hcGkvY2hhdCcsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgZ2V0U2Vzc2lvbnMoKTogUHJvbWlzZTxDaGF0U2Vzc2lvbltdPiB7XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8Q2hhdFNlc3Npb25bXT4oJy9hcGkvc2Vzc2lvbnMnKTtcclxuICB9LFxyXG5cclxuICBhc3luYyBjcmVhdGVTZXNzaW9uKCk6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcclxuICAgIHJldHVybiBmZXRjaEFwaTxDaGF0U2Vzc2lvbj4oJy9hcGkvc2Vzc2lvbnMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgc2VuZEZsZXhpYmxlUG9saWN5TWVzc2FnZShyZXF1ZXN0OiBNZXNzYWdlUmVxdWVzdCk6IFByb21pc2U8RmxleGlibGVQb2xpY3lSZXNwb25zZT4ge1xyXG4gICAgcmV0dXJuIGZldGNoQXBpPEZsZXhpYmxlUG9saWN5UmVzcG9uc2U+KCcvYXBpL3BvbGljeS1mbGV4aWJsZScsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgZ2V0U2Vzc2lvblN0YXRlKHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxTZXNzaW9uU3RhdGU+IHtcclxuICAgIHJldHVybiBmZXRjaEFwaTxTZXNzaW9uU3RhdGU+KGAvYXBpL3Nlc3Npb24tc3RhdGUvJHtzZXNzaW9uSWR9YCk7XHJcbiAgfSxcclxuXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7IG1lc3NhZ2U6IHN0cmluZyB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXBpPHsgbWVzc2FnZTogc3RyaW5nIH0+KCcvJyk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0hlYWx0aCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaGVhbHRoQ2hlY2soKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdDb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFzeW5jIHNhdmVQcm9qZWN0U3RlcFNlY3Rpb25zKHJlcXVlc3Q6IFByb2plY3RTdGVwU2VjdGlvblJlcXVlc3QpOiBQcm9taXNlPFByb2plY3RTdGVwU2VjdGlvblJlc3BvbnNlW10+IHtcclxuICAgIHJldHVybiBmZXRjaEFwaTxQcm9qZWN0U3RlcFNlY3Rpb25SZXNwb25zZVtdPignL2FwaS9wcm9qZWN0LXN0ZXAtc2VjdGlvbnMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGdldFByb2plY3RTdGVwU2VjdGlvbnMocHJvamVjdElkOiBzdHJpbmcsIHN0ZXBLZXk6IHN0cmluZyk6IFByb21pc2U8UHJvamVjdFN0ZXBTZWN0aW9uUmVzcG9uc2VbXT4ge1xyXG4gICAgcmV0dXJuIGZldGNoQXBpPFByb2plY3RTdGVwU2VjdGlvblJlc3BvbnNlW10+KGAvYXBpL3Byb2plY3Qtc3RlcC1zZWN0aW9ucy8ke3Byb2plY3RJZH0vJHtzdGVwS2V5fWApO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIHNlYXJjaENvd29ya2VycyhxdWVyeTogc3RyaW5nID0gXCJcIiwgZGVwYXJ0bWVudDogc3RyaW5nID0gXCJcIik6IFByb21pc2U8Q293b3JrZXJbXT4ge1xyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgaWYgKHF1ZXJ5KSBwYXJhbXMuYXBwZW5kKCdxJywgcXVlcnkpO1xyXG4gICAgaWYgKGRlcGFydG1lbnQpIHBhcmFtcy5hcHBlbmQoJ2RlcGFydG1lbnQnLCBkZXBhcnRtZW50KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGZldGNoQXBpPENvd29ya2VyW10+KGAvYXBpL2Nvd29ya2Vycy9zZWFyY2g/JHtwYXJhbXMudG9TdHJpbmcoKX1gKTtcclxuICB9LFxyXG5cclxuICBhc3luYyBjcmVhdGVQcm9qZWN0KHJlcXVlc3Q6IFByb2plY3RDcmVhdGVSZXF1ZXN0KTogUHJvbWlzZTxQcm9qZWN0PiB7XHJcbiAgICByZXR1cm4gZmV0Y2hBcGk8UHJvamVjdD4oJy9hcGkvcHJvamVjdHMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGdldFByb2plY3QocHJvamVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFByb2plY3Q+IHtcclxuICAgIHJldHVybiBmZXRjaEFwaTxQcm9qZWN0PihgL2FwaS9wcm9qZWN0cy8ke3Byb2plY3RJZH1gKTtcclxuICB9LFxyXG59OyJdLCJuYW1lcyI6WyJnZXRBcGlCYXNlVXJsIiwiZW5kcG9pbnQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0VORFBPSU5UIiwiaXNQcm9kIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsImluY2x1ZGVzIiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiLCJsb2ciLCJlbnZWYXJpYWJsZSIsInJlc29sdmVkRW5kcG9pbnQiLCJkZWZhdWx0RW5kcG9pbnQiLCJmaW5hbEVuZHBvaW50IiwiQVBJX0JBU0VfVVJMIiwiQXBpRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJuYW1lIiwiZmV0Y2hBcGkiLCJvcHRpb25zIiwidXJsIiwibWV0aG9kIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJzdGF0dXNUZXh0Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiY2F0Y2giLCJkYXRhIiwianNvbiIsIlR5cGVFcnJvciIsImFwaSIsInNlbmRNZXNzYWdlIiwicmVxdWVzdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0U2Vzc2lvbnMiLCJjcmVhdGVTZXNzaW9uIiwic2VuZEZsZXhpYmxlUG9saWN5TWVzc2FnZSIsImdldFNlc3Npb25TdGF0ZSIsInNlc3Npb25JZCIsImhlYWx0aENoZWNrIiwidGVzdENvbm5lY3Rpb24iLCJzYXZlUHJvamVjdFN0ZXBTZWN0aW9ucyIsImdldFByb2plY3RTdGVwU2VjdGlvbnMiLCJwcm9qZWN0SWQiLCJzdGVwS2V5Iiwic2VhcmNoQ293b3JrZXJzIiwicXVlcnkiLCJkZXBhcnRtZW50IiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwidG9TdHJpbmciLCJjcmVhdGVQcm9qZWN0IiwiZ2V0UHJvamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/api.ts\n"));

/***/ })

});